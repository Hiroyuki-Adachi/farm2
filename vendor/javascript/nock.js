import*as e from"assert";import*as t from"debug";import*as r from"querystring";import*as s from"util";import{d as o}from"./_/xcUJR7dQ.js";import*as n from"http";import*as i from"https";import*as a from"propagate";import*as c from"events";import u from"process";import h from"buffer";import*as d from"stream";import*as p from"zlib";import*as l from"json-stringify-safe";import*as f from"url";import*as y from"fs";import*as m from"path";import"timers";var g=c;try{"default"in c&&(g=c.default)}catch(e){}var b={},w=false;function dew$a(){if(w)return b;w=true;const{EventEmitter:e}=g;b=new e;return b}var k=c;try{"default"in c&&(k=c.default)}catch(e){}var v=t;try{"default"in t&&(v=t.default)}catch(e){}var q={},R=false;function dew$9(){if(R)return q;R=true;var e=h.Buffer;var t=u;const{EventEmitter:r}=k;const s=v("nock.socket");q=class Socket extends r{constructor(e){super();if(e.proto==="https"){this.authorized=true;this.encrypted=true}this.bufferSize=0;this.writableLength=0;this.writable=true;this.readable=true;this.pending=false;this.destroyed=false;this.connecting=true;this._hadError=false;this.timeout=0;const t=e.family===6;this.remoteFamily=t?"IPv6":"IPv4";this.localAddress=this.remoteAddress=t?"::1":"127.0.0.1";this.localPort=this.remotePort=parseInt(e.port)}setNoDelay(){}setKeepAlive(){}resume(){}ref(){}unref(){}write(){}address(){return{port:this.remotePort,family:this.remoteFamily,address:this.remoteAddress}}setTimeout(e,t){this.timeout=e;t&&this.once("timeout",t);return this}applyDelay(e){if(this.timeout&&e>this.timeout){s("socket timeout");this.emit("timeout")}}getPeerCertificate(){return e.from((Math.random()*1e4+Date.now()).toString()).toString("base64")}destroy(e){if(this.destroyed)return this;s("socket destroy");this.destroyed=true;this.readable=this.writable=false;this.readableEnded=this.writableFinished=true;t.nextTick((()=>{if(e){this._hadError=true;this.emit("error",e)}this.emit("close")}));return this}};return q}var E=d;try{"default"in d&&(E=d.default)}catch(e){}var C=s;try{"default"in s&&(C=s.default)}catch(e){}var S=p;try{"default"in p&&(S=p.default)}catch(e){}var O=t;try{"default"in t&&(O=t.default)}catch(e){}var _={},$=false;function dew$8(){if($)return _;$=true;var e=h.Buffer;const t=E;const r=C;const s=S;const n=O("nock.playback_interceptor");const i=o();function parseJSONRequestBody(t,r){if(!r||!i.isJSONContent(t.headers))return r;i.contentEncoding(t.headers,"gzip")?r=String(s.gunzipSync(e.from(r,"hex"))):i.contentEncoding(t.headers,"deflate")&&(r=String(s.inflateSync(e.from(r,"hex"))));return JSON.parse(r)}function parseFullReplyResult(e,t){n("full response from callback result: %j",t);if(!Array.isArray(t))throw Error("A single function provided to .reply MUST return an array");if(t.length>3)throw Error("The array returned from the .reply callback contains too many values");const[r,s="",o]=t;if(!Number.isInteger(r))throw new Error(`Invalid ${typeof r} value for status code`);e.statusCode=r;e.rawHeaders.push(...i.headersInputToRawArray(o));n("response.rawHeaders after reply: %j",e.rawHeaders);return s}function selectDefaultHeaders(e,t){if(!t.length)return[];const r=new Set;const s=[];i.forEachHeader(e,((e,t)=>{r.add(t.toLowerCase())}));i.forEachHeader(t,((e,t)=>{r.has(t.toLowerCase())||s.push(t,e)}));return s}class ReadableBuffers extends t.Readable{constructor(e,t={}){super(t);this.buffers=e}_read(e){while(this.buffers.length)if(!this.push(this.buffers.shift()))return;this.push(null)}}function convertBodyToStream(t){if(i.isStream(t))return t;if(t===void 0)return new ReadableBuffers([]);if(e.isBuffer(t))return new ReadableBuffers([t]);typeof t!=="string"&&(t=JSON.stringify(t));return new ReadableBuffers([e.from(t)])}function playbackInterceptor({req:t,socket:s,options:o,requestBodyString:n,requestBodyIsUtf8Representable:a,response:c,interceptor:u}){const{logger:h}=u.scope;function start(){t.headers=t.getHeaders();u.scope.emit("request",t,u,n);if(typeof u.errorMessage!=="undefined"){let e;e=typeof u.errorMessage==="object"?u.errorMessage:new Error(u.errorMessage);const r=u.delayBodyInMs+u.delayConnectionInMs;i.setTimeout((()=>t.destroy(e)),r);return}c.statusCode=u.statusCode;c.rawHeaders=[...u.rawHeaders];h("response.rawHeaders:",c.rawHeaders);u.req=t;if(u.replyFunction){const e=parseJSONRequestBody(t,n);let s=u.replyFunction;s.length===3&&(s=r.promisify(s));Promise.resolve(s.call(u,o.path,e)).then(continueWithResponseBody).catch((e=>t.destroy(e)));return}if(u.fullReplyFunction){const e=parseJSONRequestBody(t,n);let s=u.fullReplyFunction;s.length===3&&(s=r.promisify(s));Promise.resolve(s.call(u,o.path,e)).then(continueWithFullResponse).catch((e=>t.destroy(e)));return}if(i.isContentEncoded(u.headers)&&!i.isStream(u.body)){const t=Array.isArray(u.body)?u.body:[u.body];const r=t.map((t=>e.from(t,"hex")));const s=new ReadableBuffers(r);continueWithResponseBody(s);return}let s=u.body;if(!a&&typeof s==="string"){s=e.from(s,"hex");(!s||u.body.length>0&&s.length===0)&&(s=e.from(u.body,"utf8"))}return continueWithResponseBody(s)}function continueWithFullResponse(e){let r;try{r=parseFullReplyResult(c,e)}catch(e){t.destroy(e);return}continueWithResponseBody(r)}function prepareResponseHeaders(r){const s=[...u.scope._defaultReplyHeaders];const o=r!==void 0&&typeof r!=="string"&&!e.isBuffer(r)&&!i.isStream(r);o&&s.push("Content-Type","application/json");c.rawHeaders.push(...selectDefaultHeaders(c.rawHeaders,s));i.forEachHeader(c.rawHeaders,((e,s,o)=>{typeof e==="function"&&(c.rawHeaders[o+1]=e(t,c,r))}));c.headers=i.headersArrayToObject(c.rawHeaders)}function continueWithResponseBody(e){prepareResponseHeaders(e);const r=convertBodyToStream(e);r.pause();r.on("data",(function(e){c.push(e)}));r.on("end",(function(){c.complete=true;c.push(null);u.scope.emit("replied",t,u)}));r.on("error",(function(e){c.emit("error",e)}));const{delayBodyInMs:o,delayConnectionInMs:n}=u;function respond(){if(!i.isRequestDestroyed(t)){t.res=c;c.req=t;h("emitting response");t.emit("response",c);i.setTimeout((()=>r.resume()),o)}}s.applyDelay(n);i.setTimeout(respond,n)}i.setImmediate((()=>{i.isRequestDestroyed(t)||start()}))}_={playbackInterceptor:playbackInterceptor};return _}var P=t;try{"default"in t&&(P=t.default)}catch(e){}var B=n;try{"default"in n&&(B=n.default)}catch(e){}var H=i;try{"default"in i&&(H=i.default)}catch(e){}var N=a;try{"default"in a&&(N=a.default)}catch(e){}var I={},x=false;function dew$7(){if(x)return I;x=true;var e=h.Buffer;var t=u;const r=P("nock.request_overrider");const{IncomingMessage:s,ClientRequest:n,request:i}=B;const{request:a}=H;const c=N;const d=o();const p=dew$a();const l=dew$9();const{playbackInterceptor:f}=dew$8();function socketOnClose(e){r("socket close");if(!e.res&&!e.socket._hadError){e.socket._hadError=true;const t=new Error("socket hang up");t.code="ECONNRESET";e.emit("error",t)}e.emit("close")}class InterceptedRequestRouter{constructor({req:e,options:r,interceptors:o}){this.req=e;this.options={...r,headers:d.headersFieldNamesToLowerCase(r.headers||{},false)};this.interceptors=o;this.socket=new l(r);const n=r.timeout||r.agent&&r.agent.options&&r.agent.options.timeout;n&&this.socket.setTimeout(n);this.response=new s(this.socket);this.requestBodyBuffers=[];this.playbackStarted=false;this.readyToStartPlaybackOnSocketEvent=false;this.attachToReq();t.nextTick((()=>this.connectSocket()))}attachToReq(){const{req:t,options:s}=this;for(const[e,r]of Object.entries(s.headers))t.setHeader(e.toLowerCase(),r);s.auth&&!s.headers.authorization&&t.setHeader("authorization",`Basic ${e.from(s.auth).toString("base64")}`);t.path=s.path;t.method=s.method;t.write=(...e)=>this.handleWrite(...e);t.end=(...e)=>this.handleEnd(...e);t.flushHeaders=(...e)=>this.handleFlushHeaders(...e);s.headers.expect==="100-continue"&&d.setImmediate((()=>{r("continue");t.emit("continue")}))}connectSocket(){const{req:e,socket:t}=this;if(!d.isRequestDestroyed(e)){e.socket=e.connection=t;c(["error","timeout"],t,e);t.on("close",(()=>socketOnClose(e)));t.connecting=false;e.emit("socket",t);t.emit("connect");t.authorized&&t.emit("secureConnect");this.readyToStartPlaybackOnSocketEvent&&this.maybeStartPlayback()}}handleWrite(...s){r("request write");let[o,n]=s;const{req:i}=this;if(i.finished){const e=new Error("write after end");e.code="ERR_STREAM_WRITE_AFTER_END";t.nextTick((()=>i.emit("error",e)));return true}if(i.socket&&i.socket.destroyed)return false;if(!o)return true;e.isBuffer(o)||(o=e.from(o,n));this.requestBodyBuffers.push(o);const a=s.length>1?s[s.length-1]:void 0;typeof a==="function"&&a();d.setImmediate((function(){i.emit("drain")}));return false}handleEnd(e,t,s){r("request end");const{req:o}=this;if(typeof e==="function"){s=e;e=null}else if(typeof t==="function"){s=t;t=null}typeof s==="function"&&o.once("finish",s);e&&o.write(e,t);o.finished=true;this.maybeStartPlayback();return o}handleFlushHeaders(){r("request flushHeaders");this.maybeStartPlayback()}setHostHeaderUsingInterceptor(e){const{req:t,options:r}=this;const s="host";if(e.__nock_filteredScope&&e.__nock_scopeHost){r.headers[s]=e.__nock_scopeHost;t.setHeader(s,e.__nock_scopeHost)}else if(r.host&&!t.getHeader(s)){let e=r.host;r.port!==80&&r.port!==443||(e=e.split(":")[0]);t.setHeader(s,e)}}maybeStartPlayback(){const{req:e,socket:t,playbackStarted:r}=this;t.connecting?this.readyToStartPlaybackOnSocketEvent=true:d.isRequestDestroyed(e)||r||this.startPlayback()}startPlayback(){r("ending");this.playbackStarted=true;const{req:t,response:s,socket:o,options:u,interceptors:h}=this;Object.assign(u,{path:t.path,headers:t.getHeaders(),protocol:`${u.proto}:`});h.forEach((e=>{this.setHostHeaderUsingInterceptor(e)}));const l=e.concat(this.requestBodyBuffers);const y=d.isUtf8Representable(l);const m=l.toString(y?"utf8":"hex");const g=h.find((e=>e.match(t,u,m)));if(g){g.scope.logger("interceptor identified, starting mocking");g.markConsumed();t.emit("finish");f({req:t,socket:o,options:u,requestBodyString:m,requestBodyIsUtf8Representable:y,response:s,interceptor:g})}else{p.emit("no match",t,u,m);const e=h.some((e=>e.matchHostName(u)&&e.options.allowUnmocked));if(e&&t instanceof n){const e=u.proto==="https"?a(u):i(u);c(e,t);e.end(l)}else{const e=d.stringifyRequest(u,m);const r=new Error(`Nock: No match for request ${e}`);r.code="ERR_NOCK_NO_MATCH";r.statusCode=r.status=404;t.destroy(r)}}}}I={InterceptedRequestRouter:InterceptedRequestRouter};return I}var F=r;try{"default"in r&&(F=r.default)}catch(e){}var M={},T=false;function dew$6(){if(T)return M;T=true;var e=h.Buffer;const t=F;const r=o();M=function matchBody(s,o,n){if(o instanceof RegExp)return o.test(n);if(e.isBuffer(o)){const e=r.isUtf8Representable(o)?"utf8":"hex";o=o.toString(e)}const i=(s.headers&&(s.headers["Content-Type"]||s.headers["content-type"])||"").toString();const a=i.includes("multipart");const c=i.includes("application/x-www-form-urlencoded");let u;if(typeof o==="object"||typeof o==="function"){try{u=JSON.parse(n)}catch(e){}u!==void 0?n=u:c&&(n=t.parse(n))}if(typeof o==="function")return o.call(s,n);a||typeof n!=="string"||(n=n.replace(/\r?\n|\r/g,""));a||typeof o!=="string"||(o=o.replace(/\r?\n|\r/g,""));c&&(o=mapValuesDeep(o,(e=>e instanceof RegExp?e:`${e}`)));return r.dataEqual(o,n)};function mapValues(e,t){const r=Object.keys(e);for(const s of r)e[s]=t(e[s],s,e);return e}function mapValuesDeep(e,t){return Array.isArray(e)?e.map((e=>mapValuesDeep(e,t))):r.isPlainObject(e)?mapValues(e,(e=>mapValuesDeep(e,t))):t(e)}return M}var A=l;try{"default"in l&&(A=l.default)}catch(e){}var D=r;try{"default"in r&&(D=r.default)}catch(e){}var j=f;try{"default"in f&&(j=f.default)}catch(e){}var U=y;try{"default"in y&&(U=y.default)}catch(e){}var L={},z=false;function dew$5(){if(z)return L;z=true;var e=h.Buffer;const t=A;const r=D;const{URL:s,URLSearchParams:n}=j;const i=o();const{remove:a}=dew$4();const c=dew$6();let u;try{u=U}catch(e){}L=class Interceptor{constructor(e,t,r,o,n){const a=typeof t==="string";if(a&&!e.scopeOptions.filteringScope&&!e.basePathname&&!t.startsWith("/")&&!t.startsWith("*"))throw Error(`Non-wildcard URL path strings must begin with a slash (otherwise they won't match anything) (got: ${t})`);if(!r)throw new Error('The "method" parameter is required for an intercept call.');this.scope=e;this.interceptorMatchHeaders=[];this.method=r.toUpperCase();this.uri=t;this._key=`${this.method} ${e.basePath}${e.basePathname}${a?"":"/"}${t}`;this.basePath=this.scope.basePath;this.path=a?e.basePathname+t:t;this.queries=null;this.options=n||{};this.counter=1;this._requestBody=o;this.reqheaders=i.headersFieldNamesToLowerCase(e.scopeOptions.reqheaders||{},true);this.badheaders=i.headersFieldsArrayToLowerCase(e.scopeOptions.badheaders||[]);this.delayBodyInMs=0;this.delayConnectionInMs=0;this.optional=false;if(a&&t.includes("?")){const t=new s(this.path,"http://localhost");this.path=t.pathname;this.query(t.searchParams);this._key=`${this.method} ${e.basePath}${this.path}`}}optionally(e=true){if(typeof e!=="boolean")throw new Error("Invalid arguments: argument should be a boolean");this.optional=e;return this}replyWithError(e){this.errorMessage=e;this.options={...this.scope.scopeOptions,...this.options};this.scope.add(this._key,this);return this.scope}reply(r,s,o){if(typeof r==="function"){if(arguments.length>1)throw Error("Invalid arguments. When providing a function for the first argument, .reply does not accept other arguments.");this.statusCode=null;this.fullReplyFunction=r}else{if(r!==void 0&&!Number.isInteger(r))throw new Error(`Invalid ${typeof r} value for status code`);this.statusCode=r||200;if(typeof s==="function"){this.replyFunction=s;s=null}}this.options={...this.scope.scopeOptions,...this.options};this.rawHeaders=i.headersInputToRawArray(o);this.scope.date&&this.rawHeaders.push("Date",this.scope.date.toUTCString());this.headers=i.headersArrayToObject(this.rawHeaders.concat(this.scope._defaultReplyHeaders));if(s&&typeof s!=="string"&&!e.isBuffer(s)&&!i.isStream(s)&&!i.isContentEncoded(this.headers)){try{s=t(s)}catch(e){throw new Error("Error encoding response body into JSON")}this.headers["content-type"]||this.rawHeaders.push("Content-Type","application/json")}this.scope.contentLen&&(typeof s==="string"?this.rawHeaders.push("Content-Length",s.length):e.isBuffer(s)&&this.rawHeaders.push("Content-Length",s.byteLength));this.scope.logger("reply.headers:",this.headers);this.scope.logger("reply.rawHeaders:",this.rawHeaders);this.body=s;this.scope.add(this._key,this);return this.scope}replyWithFile(e,t,r){if(!u)throw new Error("No fs");this.filePath=t;return this.reply(e,(()=>{const e=u.createReadStream(t);e.pause();return e}),r)}reqheaderMatches(e,t){const r=this.reqheaders[t];let s=e.headers[t];s&&typeof s!=="string"&&s.toString&&(s=s.toString());if(t==="host"&&(s===void 0||r===void 0))return true;if(r!==void 0&&s!==void 0){if(typeof r==="function")return r(s);if(i.matchStringOrRegexp(s,r))return true}this.scope.logger("request header field doesn't match:",t,s,r);return false}match(e,r,s){this.scope.logger.enabled&&this.scope.logger("attempting match %s, body = %s",t(r),t(s));const o=(r.method||"GET").toUpperCase();let{path:n="/"}=r;let a;let u;const{proto:h}=r;if(this.method!==o){this.scope.logger(`Method did not match. Request ${o} Interceptor ${this.method}`);return false}this.scope.transformPathFunction&&(n=this.scope.transformPathFunction(n));const requestMatchesFilter=({name:t,value:r})=>{const s=e.getHeader(t);return typeof r==="function"?r(s):i.matchStringOrRegexp(s,r)};if(!this.scope.matchHeaders.every(requestMatchesFilter)||!this.interceptorMatchHeaders.every(requestMatchesFilter)){this.scope.logger("headers don't match");return false}const d=Object.keys(this.reqheaders).every((e=>this.reqheaderMatches(r,e)));if(!d){this.scope.logger("headers don't match");return false}if(this.scope.scopeOptions.conditionally&&!this.scope.scopeOptions.conditionally()){this.scope.logger("matching failed because Scope.conditionally() did not validate");return false}const p=this.badheaders.filter((e=>e in r.headers));if(p.length){this.scope.logger("request contains bad headers",...p);return false}if(this.queries===null)this.scope.logger("query matching skipped");else{const[e,t]=n.split("?");const r=this.matchQuery({search:t});this.scope.logger(r?"query matching succeeded":"query matching failed");if(!r)return false;n=e}u=this.__nock_filteredScope?this.__nock_filteredScope:i.normalizeOrigin(h,r.host,r.port);a=typeof this.uri==="function"?i.matchStringOrRegexp(u,this.basePath)&&this.uri.call(this,n):i.matchStringOrRegexp(u,this.basePath)&&i.matchStringOrRegexp(n,this.path);this.scope.logger(`matching ${u}${n} to ${this._key}: ${a}`);if(a&&this._requestBody!==void 0){this.scope.transformRequestBodyFunction&&(s=this.scope.transformRequestBodyFunction(s,this._requestBody));a=c(r,this._requestBody,s);a||this.scope.logger("bodies don't match: \n",this._requestBody,"\n",s)}return a}matchOrigin(e){const t=typeof this.path==="function";const r=this.path instanceof RegExp;const s=this.scope.basePath instanceof RegExp;const o=(e.method||"GET").toUpperCase();let{path:n}=e;const{proto:i}=e;r||(n=n?n.split("?")[0]:"");this.scope.transformPathFunction&&(n=this.scope.transformPathFunction(n));const a=t||r?this.__nock_scopeKey:this._key;const c=`${o} ${i}://${e.host}${n}`;return t?!!(c.match(a)&&this.path(n)):r&&!s?!!c.match(a)&&this.path.test(n):s?this.scope.basePath.test(c)&&!!n.match(this.path):a===c}matchHostName(e){const{basePath:t}=this.scope;return t instanceof RegExp?t.test(e.hostname):e.hostname===this.scope.urlParts.hostname}matchQuery(e){if(this.queries===true)return true;const t=r.parse(e.search);this.scope.logger("Interceptor queries: %j",this.queries);this.scope.logger("    Request queries: %j",t);return typeof this.queries==="function"?this.queries(t):i.dataEqual(this.queries,t)}filteringPath(...e){this.scope.filteringPath(...e);return this}markConsumed(){this.interceptionCounter++;a(this);!this.scope.shouldPersist()&&this.counter<1&&this.scope.remove(this._key,this)}matchHeader(e,t){this.interceptorMatchHeaders.push({name:e,value:t});return this}basicAuth({user:t,pass:r=""}){const s=e.from(`${t}:${r}`).toString("base64");this.matchHeader("authorization",`Basic ${s}`);return this}
/**
     * Set query strings for the interceptor
     * @name query
     * @param queries Object of query string name,values (accepts regexp values)
     * @public
     * @example
     * // Will match 'http://zombo.com/?q=t'
     * nock('http://zombo.com').get('/').query({q: 't'});
     */query(e){if(this.queries!==null)throw Error("Query parameters have already been defined");if(e===true){this.queries=e;return this}if(typeof e==="function"){this.queries=e;return this}let t;this.scope.scopeOptions.encodedQueryParams&&(t=i.percentDecode);if(e instanceof n||typeof e==="string")e=r.parse(e.toString());else if(!i.isPlainObject(e))throw Error(`Argument Error: ${e}`);this.queries={};for(const[r,s]of Object.entries(e)){const e=i.formatQueryValue(r,s,t);const[o,n]=e;this.queries[o]=n}return this}
/**
     * Set number of times will repeat the interceptor
     * @name times
     * @param newCounter Number of times to repeat (should be > 0)
     * @public
     * @example
     * // Will repeat mock 5 times for same king of request
     * nock('http://zombo.com).get('/').times(5).reply(200, 'Ok');
     */times(e){if(e<1)return this;this.counter=e;return this}once(){return this.times(1)}twice(){return this.times(2)}thrice(){return this.times(3)}
/**
     * Delay the response by a certain number of ms.
     *
     * @param {(integer|object)} opts - Number of milliseconds to wait, or an object
     * @param {integer} [opts.head] - Number of milliseconds to wait before response is sent
     * @param {integer} [opts.body] - Number of milliseconds to wait before response body is sent
     * @return {Interceptor} - the current interceptor for chaining
     */delay(e){let t;let r;if(typeof e==="number"){t=e;r=0}else{if(typeof e!=="object")throw new Error(`Unexpected input opts ${e}`);t=e.head||0;r=e.body||0}return this.delayConnection(t).delayBody(r)}
/**
     * Delay the response body by a certain number of ms.
     *
     * @param {integer} ms - Number of milliseconds to wait before response is sent
     * @return {Interceptor} - the current interceptor for chaining
     */delayBody(e){this.delayBodyInMs=e;return this}
/**
     * Delay the connection by a certain number of ms.
     *
     * @param  {integer} ms - Number of milliseconds to wait
     * @return {Interceptor} - the current interceptor for chaining
     */delayConnection(e){this.delayConnectionInMs=e;return this}};return L}var J=s;try{"default"in s&&(J=s.default)}catch(e){}var W=n;try{"default"in n&&(W=n.default)}catch(e){}var K=t;try{"default"in t&&(K=t.default)}catch(e){}var V={},Q=false;function dew$4(){if(Q)return V;Q=true;var e=u;const{InterceptedRequestRouter:t}=dew$7();const r=o();const{inherits:s}=J;const n=W;const i=K("nock.intercept");const a=dew$a();function NetConnectNotAllowedError(e,t){Error.call(this);this.name="NetConnectNotAllowedError";this.code="ENETUNREACH";this.message=`Nock: Disallowed net connect for "${e}${t}"`;Error.captureStackTrace(this,this.constructor)}s(NetConnectNotAllowedError,Error);let c={};let h;
/**
   * Enabled real request.
   * @public
   * @param {String|RegExp} matcher=RegExp.new('.*') Expression to match
   * @example
   * // Enables all real requests
   * nock.enableNetConnect();
   * @example
   * // Enables real requests for url that matches google
   * nock.enableNetConnect('google');
   * @example
   * // Enables real requests for url that matches google and amazon
   * nock.enableNetConnect(/(google|amazon)/);
   * @example
   * // Enables real requests for url that includes google
   * nock.enableNetConnect(host => host.includes('google'));
   */function enableNetConnect(e){h=typeof e==="string"?new RegExp(e):e instanceof RegExp?e:typeof e==="function"?{test:e}:/.*/}function isEnabledForNetConnect(e){r.normalizeRequestOptions(e);const t=h&&h.test(e.host);i("Net connect",t?"":"not","enabled for",e.host);return t}function disableNetConnect(){h=void 0}function isOn(){return!isOff()}function isOff(){return e.env.NOCK_OFF==="true"}function addInterceptor(e,t,r,s,o){e in c||(c[e]={key:e,interceptors:[]});t.__nock_scope=r;t.__nock_scopeKey=e;t.__nock_scopeOptions=s;t.__nock_scopeHost=o;t.interceptionCounter=0;s.allowUnmocked&&(c[e].allowUnmocked=true);c[e].interceptors.push(t)}function remove(e){if(e.__nock_scope.shouldPersist()||--e.counter>0)return;const{basePath:t}=e;const r=c[t]&&c[t].interceptors||[];r.some((function(t,s){return t===e&&r.splice(s,1)}))}function removeAll(){Object.keys(c).forEach((function(e){c[e].interceptors.forEach((function(e){e.scope.keyedInterceptors={}}))}));c={}}
/**
   * Return all the Interceptors whose Scopes match against the base path of the provided options.
   *
   * @returns {Interceptor[]}
   */function interceptorsFor(e){r.normalizeRequestOptions(e);i("interceptors for %j",e.host);const t=`${e.proto}://${e.host}`;i("filtering interceptors for basepath",t);for(const{key:e,interceptors:s,allowUnmocked:o}of Object.values(c)){for(const e of s){const{filteringScope:r}=e.__nock_scopeOptions;if(r&&r(t)){e.scope.logger("found matching scope interceptor");s.forEach((e=>{e.__nock_filteredScope=e.__nock_scopeKey}));return s}}if(r.matchStringOrRegexp(t,e)){if(o&&s.length===0){i("matched base path with allowUnmocked (no matching interceptors)");return[{options:{allowUnmocked:true},matchOrigin(){return false}}]}i(`matched base path (${s.length} interceptor${s.length>1?"s":""})`);return s}}}function removeInterceptor(e){const t=dew$5();let s,o,n,i;if(e instanceof t){s=e.basePath;o=e._key}else{i=e.proto?e.proto:"http";r.normalizeRequestOptions(e);s=`${i}://${e.host}`;n=e.method&&e.method.toUpperCase()||"GET";o=`${n} ${s}${e.path||"/"}`}if(c[s]&&c[s].interceptors.length>0){for(let r=0;r<c[s].interceptors.length;r++){const n=c[s].interceptors[r];if(e instanceof t?n===e:n._key===o){c[s].interceptors.splice(r,1);n.scope.remove(o,n);break}}return true}return false}let d;function ErroringClientRequest(t){n.OutgoingMessage.call(this);e.nextTick(function(){this.emit("error",t)}.bind(this))}s(ErroringClientRequest,n.ClientRequest);function overrideClientRequest(){i("Overriding ClientRequest");function OverriddenClientRequest(...e){const{options:s,callback:o}=r.normalizeClientRequestArgs(...e);if(Object.keys(s).length===0)throw Error("Creating a ClientRequest with empty `options` is not supported in Nock");n.OutgoingMessage.call(this);const a=interceptorsFor(s);if(isOn()&&a){i("using",a.length,"interceptors");const e=new t({req:this,options:s,interceptors:a});Object.assign(this,e);o&&this.once("response",o)}else{i("falling back to original ClientRequest");isOff()||isEnabledForNetConnect(s)?d.apply(this,arguments):r.setImmediate(function(){const e=new NetConnectNotAllowedError(s.host,s.path);this.emit("error",e)}.bind(this))}}s(OverriddenClientRequest,n.ClientRequest);d=n.ClientRequest;n.ClientRequest=OverriddenClientRequest;i("ClientRequest overridden")}function restoreOverriddenClientRequest(){i("restoring overridden ClientRequest");if(d){n.ClientRequest=d;d=void 0;i("- ClientRequest restored")}else i("- ClientRequest was not overridden")}function isActive(){return d!==void 0}function interceptorScopes(){const e=Object.values(c).map((e=>e.interceptors));const t=new Set([].concat(...e).map((e=>e.scope)));return[...t]}function isDone(){return interceptorScopes().every((e=>e.isDone()))}function pendingMocks(){return[].concat(...interceptorScopes().map((e=>e.pendingMocks())))}function activeMocks(){return[].concat(...interceptorScopes().map((e=>e.activeMocks())))}function activate(){if(d)throw new Error("Nock already active");r.overrideRequests((function(e,t,s){const{options:o,callback:i}=r.normalizeClientRequestArgs(...s);if(Object.keys(o).length===0)throw Error("Making a request with empty `options` is not supported in Nock");o.proto=e;const c=interceptorsFor(o);if(isOn()&&c){const r=c.some((e=>e.matchOrigin(o)));const s=c.some((e=>e.options.allowUnmocked));if(!r&&s){let r;if(e==="https"){const{ClientRequest:e}=n;n.ClientRequest=d;r=t(o,i);n.ClientRequest=e}else r=t(o,i);a.emit("no match",r);return r}return new n.ClientRequest(o,i)}a.emit("no match",o);if(isOff()||isEnabledForNetConnect(o))return t(o,i);{const e=new NetConnectNotAllowedError(o.host,o.path);return new ErroringClientRequest(e)}}));overrideClientRequest()}V={addInterceptor:addInterceptor,remove:remove,removeAll:removeAll,removeInterceptor:removeInterceptor,isOn:isOn,activate:activate,isActive:isActive,isDone:isDone,pendingMocks:pendingMocks,activeMocks:activeMocks,enableNetConnect:enableNetConnect,disableNetConnect:disableNetConnect,restoreOverriddenClientRequest:restoreOverriddenClientRequest,abortPendingRequests:r.removeAllTimers};return V}var G=t;try{"default"in t&&(G=t.default)}catch(e){}var X=r;try{"default"in r&&(X=r.default)}catch(e){}var Y=s;try{"default"in s&&(Y=s.default)}catch(e){}var Z={},ee=false;function dew$3(){if(ee)return Z;ee=true;var e=h.Buffer;const t=G("nock.recorder");const r=X;const{inspect:s}=Y;const n=o();const{restoreOverriddenClientRequest:i}=dew$4();const a="\n<<<<<<-- cut here --\x3e>>>>>\n";let c=false;let u=[];function getScope(e){const{proto:t,host:r,port:s}=n.normalizeRequestOptions(e);return n.normalizeOrigin(t,r,s)}function getMethod(e){return e.method||"GET"}function getBodyFromChunks(t,r){if(r&&n.isContentEncoded(r))return{body:t.map((e=>e.toString("hex")))};const s=e.concat(t);const o=n.isUtf8Representable(s);if(!o)return{isUtf8Representable:o,body:s.toString("hex")};{const e=s.toString("utf8");try{return{isUtf8Representable:o,body:JSON.parse(e)}}catch(t){return{isUtf8Representable:o,body:e}}}}function generateRequestAndResponseObject({req:e,bodyChunks:t,options:r,res:s,dataChunks:o,reqheaders:n}){const{body:i,isUtf8Representable:a}=getBodyFromChunks(o,s.headers);r.path=e.path;return{scope:getScope(r),method:getMethod(r),path:r.path,body:getBodyFromChunks(t).body,status:s.statusCode,response:i,rawHeaders:s.rawHeaders,reqheaders:n||void 0,responseIsBinary:a===false}}function generateRequestAndResponse({req:e,bodyChunks:t,options:o,res:i,dataChunks:a,reqheaders:c}){const u=getBodyFromChunks(t).body;const h=getBodyFromChunks(a,i.headers).body;let{path:d}=o;const p=e.path.indexOf("?");let l={};if(p!==-1){d=d.substring(0,p);const t=e.path.slice(p+1);l=r.parse(t)}d=d.replace(/'/g,"\\'");const f={};for(const e in l){const t=n.formatQueryValue(e,l[e],n.percentEncode);f[t[0]]=t[1]}const y=[];y.push("");const m=getScope(o);y.push(`nock('${m}', {"encodedQueryParams":true})`);const g=getMethod(o).toLowerCase();u?y.push(`  .${g}('${d}', ${JSON.stringify(u)})`):y.push(`  .${g}('${d}')`);Object.entries(c||{}).forEach((([e,t])=>{const r=JSON.stringify(e);const s=JSON.stringify(t);y.push(`  .matchHeader(${r}, ${s})`)}));p!==-1&&y.push(`  .query(${JSON.stringify(f)})`);const b=i.statusCode.toString();const w=JSON.stringify(h);const k=s(i.rawHeaders);y.push(`  .reply(${b}, ${w}, ${k});`);return y.join("\n")}let d=0;const p={dont_print:false,enable_reqheaders_recording:false,logging:console.log,output_objects:false,use_separator:true};function record(r){if(c)throw new Error("Nock recording already in progress");c=true;d+=1;const s=d;typeof r==="boolean"&&(r={dont_print:r});r={...p,...r};t("start recording",s,r);const{dont_print:o,enable_reqheaders_recording:h,logging:l,output_objects:f,use_separator:y}=r;t(s,"restoring overridden requests before new overrides");n.restoreOverriddenRequests();i();n.overrideRequests((function(r,i,c){const{options:p,callback:m}=n.normalizeClientRequestArgs(...c);const g=[];if(p._recording)return i(p,m);p._recording=true;const b=i(p,(function(i){t(s,"intercepting",r,"request to record");i.once("end",(function(){t(s,r,"intercepted request ended");let e;if(h){e=b.getHeaders();n.deleteHeadersField(e,"user-agent")}const c=f?generateRequestAndResponseObject:generateRequestAndResponse;let m=c({req:b,bodyChunks:g,options:p,res:i,dataChunks:k,reqheaders:e});t("out:",m);if(s===d){u.push(m);if(!o)if(y){typeof m!=="string"&&(m=JSON.stringify(m,null,2));l(a+m+a)}else l(m)}else t("skipping recording of an out-of-order request",m)}));let c;const{setEncoding:w}=i;i.setEncoding=function(e){c=e;return w.apply(this,arguments)};const k=[];const v=i.push;i.push=function(t){if(t){c&&(t=e.from(t,c));k.push(t)}return v.call(i,t)};m&&m(i,p,m);t("finished setting up intercepting");r==="https"&&(p.proto="https")}));const recordChunk=(o,n)=>{t(s,"new",r,"body chunk");e.isBuffer(o)||(o=e.from(o,n));g.push(o)};const w=b.write;b.write=function(e,t){if(typeof e==="undefined")throw new Error("Data was undefined.");recordChunk(e,t);w.apply(b,arguments)};const k=b.end;b.end=function(e,r,s){t("req.end");if(typeof e==="function"){s=e;e=null}else if(typeof r==="function"){s=r;r=null}e&&recordChunk(e,r);k.call(b,e,r,s)};return b}))}function restore(){t(d,"restoring all the overridden http/https properties");n.restoreOverriddenRequests();i();c=false}function clear(){u=[]}Z={record:record,outputs:()=>u,restore:restore,clear:clear};return Z}var te=e;try{"default"in e&&(te=e.default)}catch(e){}var re=f;try{"default"in f&&(re=f.default)}catch(e){}var se=t;try{"default"in t&&(se=t.default)}catch(e){}var oe=c;try{"default"in c&&(oe=c.default)}catch(e){}var ne=y;try{"default"in y&&(ne=y.default)}catch(e){}var ie={},ae=false;function dew$2(){if(ae)return ie;ae=true;var e=h.Buffer;const{addInterceptor:t,isOn:r}=dew$4();const s=o();const n=te;const i=re;const a=se("nock.scope");const{EventEmitter:c}=oe;const u=dew$5();const{URL:d,Url:p}=i;let l;try{l=ne}catch(e){}
/**
   * Normalizes the passed url for consistent internal processing
   * @param {string|LegacyUrl|URL} u
   */function normalizeUrl(e){if(!(e instanceof d))return normalizeUrl(new d(e instanceof p?i.format(e):e));if(!/https?:/.test(e.protocol))throw new TypeError(`Protocol '${e.protocol}' not recognized. This commonly occurs when a hostname and port are included without a protocol, producing a URL that is valid but confusing, and probably not what you want.`);return{href:e.href,origin:e.origin,protocol:e.protocol,username:e.username,password:e.password,host:e.host,hostname:typeof e.hostname==="string"&&e.hostname.startsWith("[")?e.hostname.slice(1,-1):e.hostname,port:e.port||(e.protocol==="http:"?80:443),pathname:e.pathname,search:e.search,searchParams:e.searchParams,hash:e.hash}}
/**
   * @param  {string|RegExp|LegacyUrl|URL} basePath
   * @param  {Object}   options
   * @param  {boolean}  options.allowUnmocked
   * @param  {string[]} options.badheaders
   * @param  {function} options.conditionally
   * @param  {boolean}  options.encodedQueryParams
   * @param  {function} options.filteringScope
   * @param  {Object}   options.reqheaders
   * @constructor
   */class Scope extends c{constructor(e,t){super();this.keyedInterceptors={};this.interceptors=[];this.transformPathFunction=null;this.transformRequestBodyFunction=null;this.matchHeaders=[];this.scopeOptions=t||{};this.urlParts={};this._persist=false;this.contentLen=false;this.date=null;this.basePath=e;this.basePathname="";this.port=null;this._defaultReplyHeaders=[];let r=String(e);if(!(e instanceof RegExp)){this.urlParts=normalizeUrl(e);this.port=this.urlParts.port;this.basePathname=this.urlParts.pathname.replace(/\/$/,"");this.basePath=`${this.urlParts.protocol}//${this.urlParts.hostname}:${this.port}`;r=this.urlParts.host}this.logger=a.extend(r)}add(e,r){e in this.keyedInterceptors||(this.keyedInterceptors[e]=[]);this.keyedInterceptors[e].push(r);t(this.basePath,r,this,this.scopeOptions,this.urlParts.hostname)}remove(e,t){if(this._persist)return;const r=this.keyedInterceptors[e];if(r){r.splice(r.indexOf(t),1);r.length===0&&delete this.keyedInterceptors[e]}}intercept(e,t,r,s){const o=new u(this,e,t,r,s);this.interceptors.push(o);return o}get(e,t,r){return this.intercept(e,"GET",t,r)}post(e,t,r){return this.intercept(e,"POST",t,r)}put(e,t,r){return this.intercept(e,"PUT",t,r)}head(e,t,r){return this.intercept(e,"HEAD",t,r)}patch(e,t,r){return this.intercept(e,"PATCH",t,r)}merge(e,t,r){return this.intercept(e,"MERGE",t,r)}delete(e,t,r){return this.intercept(e,"DELETE",t,r)}options(e,t,r){return this.intercept(e,"OPTIONS",t,r)}pendingMocks(){return this.activeMocks().filter((e=>this.keyedInterceptors[e].some((({interceptionCounter:e,optional:t})=>{const r=this._persist&&e>0;return!r&&!t}))))}activeMocks(){return Object.keys(this.keyedInterceptors)}isDone(){return!r()||this.pendingMocks().length===0}done(){n.ok(this.isDone(),`Mocks not yet satisfied:\n${this.pendingMocks().join("\n")}`)}buildFilter(){const e=arguments;return arguments[0]instanceof RegExp?function(t){if(typeof t!=="string")throw Error(`Nock internal assertion failed: typeof candidate is ${typeof t}. If you encounter this error, please report it as a bug.`);return t.replace(e[0],e[1])}:typeof arguments[0]==="function"?arguments[0]:void 0}filteringPath(){this.transformPathFunction=this.buildFilter.apply(this,arguments);if(!this.transformPathFunction)throw new Error("Invalid arguments: filtering path should be a function or a regular expression");return this}filteringRequestBody(){this.transformRequestBodyFunction=this.buildFilter.apply(this,arguments);if(!this.transformRequestBodyFunction)throw new Error("Invalid arguments: filtering request body should be a function or a regular expression");return this}matchHeader(e,t){this.matchHeaders.push({name:e.toLowerCase(),value:t});return this}defaultReplyHeaders(e){this._defaultReplyHeaders=s.headersInputToRawArray(e);return this}persist(e=true){if(typeof e!=="boolean")throw new Error("Invalid arguments: argument should be a boolean");this._persist=e;return this}
/**
     * @private
     * @returns {boolean}
     */shouldPersist(){return this._persist}replyContentLength(){this.contentLen=true;return this}replyDate(e){this.date=e||new Date;return this}clone(){return new Scope(this.basePath,this.scopeOptions)}}function loadDefs(e){if(!l)throw new Error("No fs");const t=l.readFileSync(e);return JSON.parse(t)}function load(e){return define(loadDefs(e))}function getStatusFromDefinition(e){if(e.reply!==void 0){const t=parseInt(e.reply,10);if(isNaN(t))throw Error("`reply`, when present, must be a numeric string");return t}const t=200;return e.status||t}function getScopeFromDefinition(e){if(e.port!==void 0){const t=i.parse(e.scope);if(t.port===null)return`${e.scope}:${e.port}`;if(parseInt(t.port)!==parseInt(e.port))throw new Error("Mismatched port numbers in scope and port properties of nock definition.")}return e.scope}function tryJsonParse(e){try{return JSON.parse(e)}catch(t){return e}}function define(t){const r=[];t.forEach((function(t){const s=getScopeFromDefinition(t);const o=t.path;if(!t.method)throw Error("Method is required");const n=t.method.toLowerCase();const i=getStatusFromDefinition(t);const a=t.rawHeaders||[];const c=t.reqheaders||{};const u=t.badheaders||[];const h={...t.options};h.reqheaders=c;h.badheaders=u;let d;d=t.response?t.responseIsBinary?e.from(t.response,"hex"):typeof t.response==="string"?tryJsonParse(t.response):t.response:"";const p=new Scope(s,h);Object.entries(c).forEach((([e,t])=>{p.matchHeader(e,t)}));const l=["filteringRequestBody","filteringPath"];l.forEach((e=>{t[e]&&p[e](t[e])}));p.intercept(o,n,t.body).reply(i,d,a);r.push(p)}));return r}ie={Scope:Scope,load:load,loadDefs:loadDefs,define:define};return ie}var ce=e;try{"default"in e&&(ce=e.default)}catch(e){}var ue=s;try{"default"in s&&(ue=s.default)}catch(e){}var he=m;try{"default"in m&&(he=m.default)}catch(e){}var de=t;try{"default"in t&&(de=t.default)}catch(e){}var pe=y;try{"default"in y&&(pe=y.default)}catch(e){}var le={},fe=false;function dew$1(){if(fe)return le;fe=true;const e=ce;const t=dew$3();const{activate:r,disableNetConnect:s,enableNetConnect:o,removeAll:n}=dew$4();const{loadDefs:i,define:a}=dew$2();const{format:c}=ue;const u=he;const h=de("nock.back");let d=null;let p;try{p=pe}catch(e){}
/**
   * nock the current function with the fixture given
   *
   * @param {string}   fixtureName  - the name of the fixture, e.x. 'foo.json'
   * @param {object}   options      - [optional] extra options for nock with, e.x. `{ assert: true }`
   * @param {function} nockedFn     - [optional] callback function to be executed with the given fixture being loaded;
   *                                  if defined the function will be called with context `{ scopes: loaded_nocks || [] }`
   *                                  set as `this` and `nockDone` callback function as first and only parameter;
   *                                  if not defined a promise resolving to `{nockDone, context}` where `context` is
   *                                  aforementioned `{ scopes: loaded_nocks || [] }`
   *
   * List of options:
   *
   * @param {function} before       - a preprocessing function, gets called before nock.define
   * @param {function} after        - a postprocessing function, gets called after nock.define
   * @param {function} afterRecord  - a postprocessing function, gets called after recording. Is passed the array
   *                                  of scopes recorded and should return the array scopes to save to the fixture
   * @param {function} recorder     - custom options to pass to the recorder
   *
   */function Back(e,t,r){if(!Back.fixtures)throw new Error("Back requires nock.back.fixtures to be set\nEx:\n\trequire(nock).back.fixtures = '/path/to/fixtures/'");if(typeof e!=="string")throw new Error("Parameter fixtureName must be a string");if(arguments.length===1)t={};else if(arguments.length===2&&typeof t==="function"){r=t;t={}}d.setup();const s=u.join(Back.fixtures,e);const o=d.start(s,t);const nockDone=function(){d.finish(s,t,o)};h("context:",o);if(typeof r!=="function")return Promise.resolve({nockDone:nockDone,context:o});r.call(o,nockDone)}const l={setup:function(){n();t.restore();r();o()},start:function(){return load()},finish:function(){}};const f={setup:function(){t.restore();n();r();o()},start:function(e,t){const r=load(e,t);o();return r},finish:function(){}};const y={setup:function(){t.restore();t.clear();n();r();s()},start:function(e,r){if(!p)throw new Error("no fs");const s=load(e,r);if(!s.isLoaded){t.record({dont_print:true,output_objects:true,...r.recorder});s.isRecording=true}return s},finish:function(e,r,s){if(s.isRecording){let s=t.outputs();typeof r.afterRecord==="function"&&(s=r.afterRecord(s));s=typeof s==="string"?s:JSON.stringify(s,null,4);h("recorder outputs:",s);p.mkdirSync(u.dirname(e),{recursive:true});p.writeFileSync(e,s)}}};const m={setup:function(){t.restore();t.clear();n();r();s()},start:function(e,r){if(!p)throw new Error("no fs");const s=removeFixture(e);t.record({dont_print:true,output_objects:true,...r.recorder});s.isRecording=true;return s},finish:function(e,r,s){let o=t.outputs();typeof r.afterRecord==="function"&&(o=r.afterRecord(o));o=typeof o==="string"?o:JSON.stringify(o,null,4);h("recorder outputs:",o);p.mkdirSync(u.dirname(e),{recursive:true});p.writeFileSync(e,o)}};const g={setup:function(){t.restore();t.clear();n();r();s()},start:function(e,t){return load(e,t)},finish:function(){}};function load(e,t){const r={scopes:[],assertScopesFinished:function(){assertScopes(this.scopes,e)},query:function(){const e=this.scopes.map((e=>e.interceptors.map((e=>({method:e.method,uri:e.uri,basePath:e.basePath,path:e.path,queries:e.queries,counter:e.counter,body:e.body,statusCode:e.statusCode,optional:e.optional})))));return[].concat.apply([],e)}};if(e&&fixtureExists(e)){let s=i(e);applyHook(s,t.before);s=a(s);applyHook(s,t.after);r.scopes=s;r.isLoaded=true}return r}function removeFixture(e,t){const r={scopes:[],assertScopesFinished:function(){}};e&&fixtureExists(e)&&(p.rmSync?p.rmSync(e):p.unlinkSync(e));r.isLoaded=false;return r}function applyHook(e,t){if(t){if(typeof t!=="function")throw new Error("processing hooks must be a function");e.forEach(t)}}function fixtureExists(e){if(!p)throw new Error("no fs");return p.existsSync(e)}function assertScopes(t,r){const s=t.filter((e=>!e.isDone())).map((e=>e.pendingMocks()));s.length&&e.fail(c("%j was not used, consider removing %s to rerecord fixture",[].concat(...s),r))}const b={wild:l,dryrun:f,record:y,update:m,lockdown:g};Back.setMode=function(e){if(!(e in b))throw new Error(`Unknown mode: ${e}`);Back.currentMode=e;h("New nock back mode:",Back.currentMode);d=b[e];d.setup()};Back.fixtures=null;Back.currentMode=null;le=Back;return le}var ye={},me=false;function dew(){if(me)return ye;me=true;var e=u;const t=dew$1();const r=dew$a();const{activate:s,isActive:o,isDone:n,isOn:i,pendingMocks:a,activeMocks:c,removeInterceptor:h,disableNetConnect:d,enableNetConnect:p,removeAll:l,abortPendingRequests:f}=dew$4();const y=dew$3();const{Scope:m,load:g,loadDefs:b,define:w}=dew$2();ye=(e,t)=>new m(e,t);Object.assign(ye,{activate:s,isActive:o,isDone:n,pendingMocks:a,activeMocks:c,removeInterceptor:h,disableNetConnect:d,enableNetConnect:p,cleanAll:l,abortPendingRequests:f,load:g,loadDefs:b,define:w,emitter:r,recorder:{rec:y.record,clear:y.clear,play:y.outputs},restore:y.restore,back:t});i()&&t.setMode(e.env.NOCK_BACK_MODE||"dryrun");return ye}var ge=dew();export{ge as default};

