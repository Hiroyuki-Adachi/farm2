import t from"assert";import e from"path";import r from"fs";import o from"glob";import i from"process";var n={};var c=i;const l=t;const s=e;const f=r;let a=void 0;try{a=o}catch(t){}const u={nosort:true,silent:true};let d=0;const E="win32"===c.platform;const defaults=t=>{const e=["unlink","chmod","stat","lstat","rmdir","readdir"];e.forEach(e=>{t[e]=t[e]||f[e];e+="Sync";t[e]=t[e]||f[e]});t.maxBusyTries=t.maxBusyTries||3;t.emfileWait=t.emfileWait||1e3;false===t.glob&&(t.disableGlob=true);if(true!==t.disableGlob&&void 0===a)throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");t.disableGlob=t.disableGlob||false;t.glob=t.glob||u};const rimraf=(t,e,r)=>{if("function"===typeof e){r=e;e={}}l(t,"rimraf: missing path");l.equal(typeof t,"string","rimraf: path should be a string");l.equal(typeof r,"function","rimraf: callback function required");l(e,"rimraf: invalid options argument provided");l.equal(typeof e,"object","rimraf: options should be object");defaults(e);let o=0;let i=null;let n=0;const next=t=>{i=i||t;0===--n&&r(i)};const afterGlob=(t,i)=>{if(t)return r(t);n=i.length;if(0===n)return r();i.forEach(t=>{const CB=r=>{if(r){if(("EBUSY"===r.code||"ENOTEMPTY"===r.code||"EPERM"===r.code)&&o<e.maxBusyTries){o++;return setTimeout(()=>rimraf_(t,e,CB),100*o)}if("EMFILE"===r.code&&d<e.emfileWait)return setTimeout(()=>rimraf_(t,e,CB),d++);"ENOENT"===r.code&&(r=null)}d=0;next(r)};rimraf_(t,e,CB)})};if(e.disableGlob||!a.hasMagic(t))return afterGlob(null,[t]);e.lstat(t,(r,o)=>{if(!r)return afterGlob(null,[t]);a(t,e.glob,afterGlob)})};const rimraf_=(t,e,r)=>{l(t);l(e);l("function"===typeof r);e.lstat(t,(o,i)=>{if(o&&"ENOENT"===o.code)return r(null);o&&"EPERM"===o.code&&E&&fixWinEPERM(t,e,o,r);if(i&&i.isDirectory())return rmdir(t,e,o,r);e.unlink(t,o=>{if(o){if("ENOENT"===o.code)return r(null);if("EPERM"===o.code)return E?fixWinEPERM(t,e,o,r):rmdir(t,e,o,r);if("EISDIR"===o.code)return rmdir(t,e,o,r)}return r(o)})})};const fixWinEPERM=(t,e,r,o)=>{l(t);l(e);l("function"===typeof o);e.chmod(t,438,i=>{i?o("ENOENT"===i.code?null:r):e.stat(t,(i,n)=>{i?o("ENOENT"===i.code?null:r):n.isDirectory()?rmdir(t,e,r,o):e.unlink(t,o)})})};const fixWinEPERMSync=(t,e,r)=>{l(t);l(e);try{e.chmodSync(t,438)}catch(t){if("ENOENT"===t.code)return;throw r}let o;try{o=e.statSync(t)}catch(t){if("ENOENT"===t.code)return;throw r}o.isDirectory()?rmdirSync(t,e,r):e.unlinkSync(t)};const rmdir=(t,e,r,o)=>{l(t);l(e);l("function"===typeof o);e.rmdir(t,i=>{!i||"ENOTEMPTY"!==i.code&&"EEXIST"!==i.code&&"EPERM"!==i.code?i&&"ENOTDIR"===i.code?o(r):o(i):rmkids(t,e,o)})};const rmkids=(t,e,r)=>{l(t);l(e);l("function"===typeof r);e.readdir(t,(o,i)=>{if(o)return r(o);let n=i.length;if(0===n)return e.rmdir(t,r);let c;i.forEach(o=>{rimraf(s.join(t,o),e,o=>{if(!c){if(o)return r(c=o);0===--n&&e.rmdir(t,r)}})})})};const rimrafSync=(t,e)=>{e=e||{};defaults(e);l(t,"rimraf: missing path");l.equal(typeof t,"string","rimraf: path should be a string");l(e,"rimraf: missing options");l.equal(typeof e,"object","rimraf: options should be object");let r;if(e.disableGlob||!a.hasMagic(t))r=[t];else try{e.lstatSync(t);r=[t]}catch(o){r=a.sync(t,e.glob)}if(r.length)for(let t=0;t<r.length;t++){const o=r[t];let i;try{i=e.lstatSync(o)}catch(t){if("ENOENT"===t.code)return;"EPERM"===t.code&&E&&fixWinEPERMSync(o,e,t)}try{i&&i.isDirectory()?rmdirSync(o,e,null):e.unlinkSync(o)}catch(t){if("ENOENT"===t.code)return;if("EPERM"===t.code)return E?fixWinEPERMSync(o,e,t):rmdirSync(o,e,t);if("EISDIR"!==t.code)throw t;rmdirSync(o,e,t)}}};const rmdirSync=(t,e,r)=>{l(t);l(e);try{e.rmdirSync(t)}catch(o){if("ENOENT"===o.code)return;if("ENOTDIR"===o.code)throw r;"ENOTEMPTY"!==o.code&&"EEXIST"!==o.code&&"EPERM"!==o.code||rmkidsSync(t,e)}};const rmkidsSync=(t,e)=>{l(t);l(e);e.readdirSync(t).forEach(r=>rimrafSync(s.join(t,r),e));const r=E?100:1;let o=0;do{let i=true;try{const n=e.rmdirSync(t,e);i=false;return n}finally{if(++o<r&&i)continue}}while(true)};n=rimraf;rimraf.sync=rimrafSync;var m=n;export default m;

